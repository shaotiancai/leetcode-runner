# 链表和二叉树
  
  本小节的题目主要关于链表结构，链表和二叉树的节点可以分别如下所示。
  ```python
  # 链表节点
  class ListNode:
    def __init__(self, val):
      self.val = val
      self.next = None
      
  # 树节点
  class ListNode:
    def __init__(self, val):
      self.val = val
      self.left = None
      self.right = None
  ```
  + 链表操作
    - 反转：pre, cur
    - 有序合并
    - 每K个一组反转：基于反转链表，将head, tail依次正确相连
    - 判断是否有环：用fast、slow指针，slow走一步，fast走两步，若相遇，则有环；否则，无环
    - 判断环的入口：设置fast、slow指针。首先，找到fast、slow相遇的点；其次，从起点head和相遇点meet同时出发，直到再次相遇，则为环的入口
    - 倒数第n个节点：用fast、slow指针，fast先提前走n+1步
    - 两个链表公共节点：计算两个链表长度的差d，让长的链表提前走d步，之后两个链接同时走
    - 两个链表相加：反转，再while循环，bit进位
    - 合并k个已排序的链表：每次取出k个链表的最小值，没有返回-1
    - 单链表的排序：用快速排序算法，将切分位置换位节点指针
    - 链表回文：反转，找到中间点，首尾同时向中间靠拢，并判断是否相同
    - 指定区间内反转：找到区间的头尾，区间外的头尾，反转后，头连头，尾连尾
    - 删除有序链表中重复元素：若重复，记录重复前一位，走到非重复停止，连接，依次遍历链表
    - 重排链表：找到中间点，后半部分反转，首尾同时移动，合并
  
  + 二叉树操作
    - 先序、中序、后序：递归或者迭代
    - 层次遍历：queue
    - 之字形打印：在层次遍历基础上，用标志位tag每次更改方向
    - 在二叉树中找到两个节点的公共祖先：用后序递归。终止条件，空或者找到其中一个节点；单层递归，左空返回右，右空返回左，都不空返回root
    - 重建二叉树：先取出先序或者后序的一个数值，接着在中序中找到割点。将左右两组分别递归，采用左闭右开原则。
    - 输出二叉树的右视图：用层次遍历，每次输出最后一个。
    - 二叉树的最大深度：深度一般用先序遍历，**但这道求解最大深度恰好等同于求根节点的最大高度**，则可用后序遍历进行求解。
    - 判断是不是平衡二叉树：用后序遍历，判断左右子树的高度差是否大于1
    - 根节点到叶子节点的所有路径和：回溯存储所有路径，再求和
    - 和为某一值的路径：回溯，查找，存储
    - 搜索二叉树判断：设置前指针pre，left > pre即返回false
    - 完全二叉树判断：层次遍历，找到初次左右不为空，标记；继续遍历，若出现，则非完全二叉树
    - 对称二叉树：终止条件，空和不等；左右子树，内外两侧都为真
    - 搜索树等k个节点：中序遍历，第k停下
  
